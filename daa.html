<!DOCTYPE html>
<html>
    <head>
        <title>Example</title>
    </head>
    <body>
      <h1>Assign 1 - mul 20 digit number</h1><pre>
      def mul(n1, n2, n):
    if n==1:
        return int(n1)*int(n2)
    c2 = mul(n1[:n//2], n2[:n//2], n//2)
    c0 = mul(n1[n//2:], n2[n//2:], n//2)
    c1 = mul(str(int(n1[:n//2])+int(n1[n//2:])),str(int(n2[:n//2])+int(n2[n//2:])), n//2)
    c1 = c1 - (c2 + c0)
    return c2*(10**n) + c1*(10**(n//2)) + c0
n1, n2 = map(str, input().split())
length = max(len(n1), len(n2))
n1 = n1.rjust(length + length%2, "0")
n2 = n2.rjust(length + length%2, "0")
print(str(mul(n1,n2,length)))
      
      <h1>Assign 2 - Job Scheduling</h1>
      import java.util.*;
public class job
{
  public static void main(String args[])
  {
    Scanner sc=new Scanner(System.in);
    System.out.println("Enter the number of Jobs");
    int n=sc.nextInt();
    String a[]=new String[n];
    int b[]=new int[n];
    int c[]=new int[n];
    for(int i=0;i<n;i++)
    {
      System.out.println("Enter the Jobs");
      a[i]=sc.next();
      System.out.println("Enter the Profit");
      b[i]=sc.nextInt();
      System.out.println("Enter the DeadLine");
      c[i]=sc.nextInt();
    }
    System.out.println("--Arranged Order--");
    System.out.print("Jobs:    ");
    for(int i=0;i<n;i++)
    {
      System.out.print(a[i]+" ");
    }
    System.out.println();
    System.out.print("Profit:  ");
    for(int i=0;i<n;i++)
    {
      System.out.print(b[i]+" ");
    }
    System.out.println();
    System.out.print("DeadLine:");
    for(int i=0;i<n;i++)
    {
      System.out.print(c[i]+" ");
    }
    for(int i=0;i<n-1;i++)
    {
      for(int j=i+1;j<n;j++)
      {
          if(b[i]<b[j])
          {
              int temp=b[i];
              b[i]=b[j];
               b[j]=temp;

              temp=c[i];
              c[i]=c[j];
               c[j]=temp;

              String temp1=a[i];
              a[i]=a[j];
               a[j]=temp1;
          }
      }
    }
    System.out.println();
    System.out.println("--Sorted Order--");
    System.out.print("Jobs:    ");
    for(int i=0;i<n;i++)
    {
      System.out.print(a[i]+" ");
    }
    System.out.println();
    System.out.print("Profit:  ");
    for(int i=0;i<n;i++)
    {
      System.out.print(b[i]+" ");
    }
    System.out.println();
    System.out.print("DeadLine:");
    for(int i=0;i<n;i++)
    {
      System.out.print(c[i]+" ");
    }
    System.out.println();
    int max=c[0];
    for(int i=0;i<n;i++)
    {
      if(c[i]>max)
      {
        max=c[i];
      }
    }
    String x[]=new String[max];
    int profit=0;
    for(int i=0;i<n;i++)
    {
      int pp=c[i];
      pp=pp-1;
      if(x[pp]==null )
      {
        x[pp]=a[i];
        profit+=b[i];
      }
      else
      {
        while(pp!=-1)
        {
          if(x[pp]==null)
          {
            x[pp]=a[i];
            profit+=b[i];
            break;
          }
            pp=pp-1;
        }
      }
    }
    for(int i=0;i<max;i++)
    {
        System.out.print("-->"+x[i]);
    }
    System.out.println();
    System.out.print("Profit Earned"+profit);
    sc.close();
 }
}

    
    <h1>Assign 3 - Floyd</h1>
    import java.util.*;
import java.util.List;
 
class floydwarshal
{
    // Recursive function to print path of given vertex `u` from source vertex `v`
    private static void printPath(int[][] path, int v, int u, List<Integer> route)
    {
        if (path[v][u] == v) {
            return;
        }
        printPath(path, v, path[v][u], route);
        route.add(path[v][u]);
    }
 
    // Function to print the shortest cost with path information between
    // all pairs of vertices
    private static void printSolution(int[][] path, int n)
    {
        for (int v = 0; v < n; v++)
        {
            for (int u = 0; u < n; u++)
            {
                if (u != v && path[v][u] != -1)
                {
                    List<Integer> route = new ArrayList<>();
                    route.add(v);
                    printPath(path, v, u, route);
                    route.add(u);
                    System.out.printf("The shortest path from %d —> %d is %s\n", v, u, route);
                }
            }
        }
    }
 
    // Function to run the Floyd–Warshall algorithm
    public static void floydWarshall(int[][] adjMatrix)
    {
        // base case
        if (adjMatrix ==null || adjMatrix.length == 0) {
            return;
        }
 
        // total number of vertices in the `adjMatrix`
        int n = adjMatrix.length;
 
        // cost[] and path[] stores shortest path
        // (shortest cost/shortest route) information
        int[][] cost = new int[n][n];
        int[][] path = new int[n][n];
 
        // initialize cost[] and path[]
        for (int v = 0; v < n; v++)
        {
            for (int u = 0; u < n; u++)
            {
                // initially, cost would be the same as the weight of the edge
                cost[v][u] = adjMatrix[v][u];
 
                if (v == u) {
                    path[v][u] = 0;
                }
                else if (cost[v][u] != Integer.MAX_VALUE) {
                    path[v][u] = v;
                }
                else {
                    path[v][u] = -1;
                }
            }
        }
 
        // run Floyd–Warshall
        for (int k = 0; k < n; k++)
        {
            for (int v = 0; v < n; v++)
            {
                for (int u = 0; u < n; u++)
                {
                    // If vertex `k` is on the shortest path from `v` to `u`,
                    // then update the value of cost[v][u] and path[v][u]
 
                    if (cost[v][k] != Integer.MAX_VALUE
                            && cost[k][u] != Integer.MAX_VALUE
                            && (cost[v][k] + cost[k][u] < cost[v][u]))
                    {
                        cost[v][u] = cost[v][k] + cost[k][u];
                        path[v][u] = path[k][u];
                    }
                }
 
                // if diagonal elements become negative, the
                // graph contains a negative-weight cycle
                if (cost[v][v] < 0)
                {
                    System.out.println("Negative-weight cycle found!!");
                    return;
                }
            }
        }
 
        // Print the shortest path between all pairs of vertices
        printSolution(path, n);
        
        
    }
 
    public static void main(String[] args)
    {
        // given adjacency representation of the matrix
        // {
            //     { 0, I, -2, I },
            //     { 4, 0, 3, I },
            //     { I, I, 0, 2 },
            //     { I, -1, I, 0 }
            // };
            
          
        Scanner sc=new Scanner(System.in);
        System.out.println("Enter size ");
        int n=sc.nextInt();
        int[][] adjMatrix = new int[n][n];
        System.out.println("Enter elements (use 9999 for infinity)");
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                adjMatrix[i][j]=sc.nextInt();
                if(adjMatrix[i][j] == 9999){
                    adjMatrix[i][j] = Integer.MAX_VALUE;
                }
            }
        }
 
        // Run Floyd–Warshall algorithm
        floydWarshall(adjMatrix);
        sc.close();
    }
}
    
    
    <h1>Assign 4 - Djikstra</h1>
import java.util.*;
class dijkstra_with_path {

	private static final int NO_PARENT = -1;

	// Function that implements Dijkstra's
	// single source shortest path
	// algorithm for a graph represented
	// using adjacency matrix
	// representation
	private static void dijkstra(int[][] adjacencyMatrix,
										int startVertex)
	{
		int nVertices = adjacencyMatrix[0].length;

		// shortestDistances[i] will hold the
		// shortest distance from src to i
		int[] shortestDistances = new int[nVertices];

		// added[i] will true if vertex i is
		// included / in shortest path tree
		// or shortest distance from src to
		// i is finalized
		boolean[] added = new boolean[nVertices];

		// Initialize all distances as
		// INFINITE and added[] as false
		for (int vertexIndex = 0; vertexIndex < nVertices;
											vertexIndex++)
		{
			shortestDistances[vertexIndex] = Integer.MAX_VALUE;
			added[vertexIndex] = false;
		}
		
		// Distance of source vertex from
		// itself is always 0
		shortestDistances[startVertex] = 0;

		// Parent array to store shortest
		// path tree
		int[] parents = new int[nVertices];

		// The starting vertex does not
		// have a parent
		parents[startVertex] = NO_PARENT;

		// Find shortest path for all
		// vertices
		for (int i = 1; i < nVertices; i++)
		{

			// Pick the minimum distance vertex
			// from the set of vertices not yet
			// processed. nearestVertex is
			// always equal to startNode in
			// first iteration.
			int nearestVertex = -1;
			int shortestDistance = Integer.MAX_VALUE;
			for (int vertexIndex = 0;
					vertexIndex < nVertices;
					vertexIndex++)
			{
				if (!added[vertexIndex] &&
					shortestDistances[vertexIndex] <
					shortestDistance)
				{
					nearestVertex = vertexIndex;
					shortestDistance = shortestDistances[vertexIndex];
				}
			}

			// Mark the picked vertex as
			// processed
			added[nearestVertex] = true;

			// Update dist value of the
			// adjacent vertices of the
			// picked vertex.
			for (int vertexIndex = 0;
					vertexIndex < nVertices;
					vertexIndex++)
			{
				int edgeDistance = adjacencyMatrix[nearestVertex][vertexIndex];
				
				if (edgeDistance > 0
					&& ((shortestDistance + edgeDistance) <
						shortestDistances[vertexIndex]))
				{
					parents[vertexIndex] = nearestVertex;
					shortestDistances[vertexIndex] = shortestDistance +
													edgeDistance;
				}
			}
		}

		printSolution(startVertex, shortestDistances, parents);
	}

	// A utility function to print
	// the constructed distances
	// array and shortest paths
	private static void printSolution(int startVertex,
									int[] distances,
									int[] parents)
	{
		int nVertices = distances.length;
		System.out.print("Vertex\t Distance\tPath");
		
		for (int vertexIndex = 0;
				vertexIndex < nVertices;
				vertexIndex++)
		{
			if (vertexIndex != startVertex)
			{
				System.out.print("\n" + startVertex + " -> ");
				System.out.print(vertexIndex + " \t\t ");
				System.out.print(distances[vertexIndex] + "\t\t");
				printPath(vertexIndex, parents);
			}
		}
	}

	// Function to print shortest path
	// from source to currentVertex
	// using parents array
	private static void printPath(int currentVertex,
								int[] parents)
	{
		
		// Base case : Source node has
		// been processed
		if (currentVertex == NO_PARENT)
		{
			return;
		}
		printPath(parents[currentVertex], parents);
		System.out.print(currentVertex + " ");
	}

		// Driver Code
	public static void main(String[] args)
	{
		Scanner sc=new Scanner(System.in);
        System.out.println("Enter size ");
        int n=sc.nextInt();
        int[][] adjMatrix = new int[n][n];
        System.out.println("Enter elements (use 9999 for infinity)");
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                adjMatrix[i][j]=sc.nextInt();
                if(adjMatrix[i][j] == 9999){
                    adjMatrix[i][j] =  Integer.MAX_VALUE;
                }
            }
        }
		dijkstra(adjMatrix, 0);
        sc.close();
	}
}


// 0, 4, 0, 0, 0, 0, 0, 8, 0 },
//  4, 0, 8, 0, 0, 0, 0, 11, 0 },
//  0, 8, 0, 7, 0, 4, 0, 0, 2 },
//  0, 0, 7, 0, 9, 14, 0, 0, 0 },
//  0, 0, 0, 9, 0, 10, 0, 0, 0 },
//  0, 0, 4, 0, 10, 0, 2, 0, 0 },
//  0, 0, 0, 14, 0, 2, 0, 1, 6 },
//  8, 11, 0, 0, 0, 0, 1, 0, 7 },
//  0, 0, 2, 0, 0, 0, 6, 7, 0 }

<h1>Assign 5 - KnightRider</h1>
class knightrider2 {
	static int N = 8;
	/* A utility function to check if i,j are
	valid indexes for N*N chessboard */
	static boolean isSafe(int x, int y, int sol[][])
	{
		return (x >= 0 && x < N && y >= 0 && y < N
				&& sol[x][y] == -1);
	}

	/* A utility function to print solution
	matrix sol[N][N] */
	static void printSolution(int sol[][])
	{
		for (int x = 0; x < N; x++) {
			for (int y = 0; y < N; y++)
				System.out.print(sol[x][y] + " ");
			System.out.println();
		}
	}

	/* This function solves the Knight Tour problem
	using Backtracking. This function mainly
	uses solveKTUtil() to solve the problem. It
	returns false if no complete tour is possible,
	otherwise return true and prints the tour.
	Please note that there may be more than one
	solutions, this function prints one of the
	feasible solutions. */
	static boolean solveKT()
	{
		int sol[][] = new int[8][8];

		/* Initialization of solution matrix */
		for (int x = 0; x < N; x++)
			for (int y = 0; y < N; y++)
				sol[x][y] = -1;

		/* xMove[] and yMove[] define next move of Knight.
		xMove[] is for next value of x coordinate
		yMove[] is for next value of y coordinate */
		int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };
		int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };

		// Since the Knight is initially at the first block
		sol[0][0] = 0;
        
		/* Start from 0,0 and explore all tours using
		solveKTUtil() */
		if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {
			System.out.println("Solution does not exist");
			return false;
		}
		else
			printSolution(sol);

		return true;
	}

	/* A recursive utility function to solve Knight
	Tour problem */
	static boolean solveKTUtil(int x, int y, int movei,
							int sol[][], int xMove[],
							int yMove[])
	{
		int k, next_x, next_y;
		if (movei == N * N) return true;
		/* Try all next moves from the current coordinate
			x, y */
		for (k = 0; k < 8; k++) {
			next_x = x + xMove[k];
			next_y = y + yMove[k];
			if (isSafe(next_x, next_y, sol)) {
				sol[next_x][next_y] = movei;
				if (solveKTUtil(next_x, next_y, movei + 1,
								sol, xMove, yMove))
					return true;
				else
					sol[next_x][next_y]
						= -1; // backtracking
			}
		}
		return false;
	}
	/* Program Start */
	public static void main(String args[])
	{
		solveKT();
	}
}

    </pre>
    </body>
</html>
